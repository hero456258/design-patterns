# design-patterns
java设计模式: 
    七大原则: 
        (1) 单一职责原则
                基本介绍: 
                      对类来说的，即一个类应该只负责一项职责。 如类A负责两个不同职责: 职责1，职责2。 当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2.
        (2) 接口隔离原则
                基本介绍: 
                      客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上
        (3) 依赖倒转(倒置)原则
                基本介绍: 
                      1）高层模块不应该依赖底层模块，二者都应该依赖其抽象
                      2）抽象不应该依赖细节，细节应该依赖抽象
                      3）依赖倒转(倒置)的中心思想是面向接口编程
                      4）依赖倒转原则是基于这样的设计理念: 相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类
                      5）使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成
        
        (4) 里氏替换原则
                基本介绍: 
                     1) 里式替换原则(Liskov Substitution Principle) 在1988年，由麻省理工学院的一位姓里氏的女士提出的。
                     2) 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成 o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。
                        换句话说，所有引用基类的地方必须能透明地使用其子类的对象。
                     3) 在使用继承时，遵循里式替换原则，在子类中尽量不要重新父类的方法
                     4) 里式替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖 来解决问题。
       
        (5) 开闭原则
               基本介绍: 
                      1) 开闭原则(Open Closed Principle) 是编程中最基础、最重要 的设计原则
         
                      2) 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。
         
                      3) 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
         
                      4) 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则  。
        
        (6) 迪米特法则
                基本介绍: 
                     1) 一个对象应该对其他对象保持最少的了解
                     2) 类与类关系越密切，耦合度越大
                     3) 迪米特法则(Demeter Principle) 又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。
                         对外除了提供public方法，不对外泄露任何信息
                     4) 迪米特法则还有个更简单的定义: 只与直接的朋友通信
                     5) 直接的朋友: 每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多: 依赖，关联，组合，聚合等。
                         其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生类最好不要以局部变量的形式出现
                         在类的内部。

        
        (7) 合成复用原则

    UML类图: 
                    基本介绍: 
                        1) UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果
                        2) UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等，如下图:
                
                    UML类图:
                         1) 用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系。
                         2) 类之间的关系: 依赖、泛化(继承)、实现、关联、聚合与组合。
                         
    设计模式概述: 
        4.1 掌握设计模式的层次

             1) 第一层: 刚开始学编程不久，听说过什么是设计模式
             2) 第二层: 有很长时间的编程经验，自己写了很多代码，其中用到了设计模式，但是自己不知道
             3) 第三层: 学习过了设计模式，发现自己已经在使用了，并且发现了一些新的模式挺好用的
             4) 第四层: 阅读了很多别人写的源码和框架，在其中看到别人设计模式，并且能够领会设计模式的精妙和带来的好处
             5) 第五层: 代码写着写着，自己都没有意识到使用了设计模式，并且熟练的写了出来
             
        4.2 设计模式介绍
             1) 设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式(Design Pattern)代表了最佳的实践。
                这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
             2) 设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度。
             3) 《设计模式》是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design (俗称"GOF四人组")
             4) 设计模式并不局限于某种语言，Java，php，C++ 都有设计模式
             
        4.3 设计模式类型
                设计模式分为三种类型，共23种
                  1) 创建型模式: 单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。
                  2) 结构型模式: 适配器模式，桥接模式、装饰模式、组合模式、享元模式、代理模式。
                  3) 行为型模式: 模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式(Interpreter模式)、状态模式、
                      策略模式、职责链模式(责任链模式)。
             注意: 不同的书籍上对分类和名称略有差别
             
     单例设计模式: 
                单例模式有八种方式: 
                             1) 饿汉式(静态常量)
                             2) 饿汉式(静态代码块)
                             3) 懒汉式(线程不安全)
                             4) 懒汉式(线程安全，同步方法)
                             5) 懒汉式(线程安全，同步代码块)
                             6) 双重检查
                             7) 静态内部类
                             8) 枚举
                单例模式注意事项和细节说明
                             1) 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统的性能
                             2) 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方式，而不是使用new
                             3) 单例模式使用的场景: 需要频繁的进行创建和销毁对象、创建对象时耗时过多或耗费资源过多(即: 重量级对象) ，但又经常用到的对象、
                                工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等)

     简单工厂模式: 
             基本介绍: 
                1) 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。
                   简单工厂模式是工厂模式家族中最简单实用的模式。
                2) 简单工厂模式: 定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)  
                3) 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂设计模式。
                
                
     工厂方法模式: 
             基本介绍: 
                1) 工厂方法模式设计方案: 将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。
                2) 工厂方法模式: 定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。
                
     抽象工厂方法模式:
             基本介绍
                1) 抽象工厂模式: 定义了一个 interface 用于创建相关或有依赖关系的对象簇，而无需指明具体的类
                2) 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
                3) 从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。
                4) 将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。 程序员可以根据创建对象类型使用对应的工厂子类。
                   这样将单个简单工厂类变成了工厂簇，便利于代码的维护和扩展。
                   
       工厂模式小结
                 1) 工厂模式的意义
                     将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性
                 2) 三种工厂模式(简单工厂模式、工厂方法模式、抽象工厂模式)
                 3) 设计模式的依赖抽象原则: 
                        ① 创建对象实例时，不要直接new 类，而是把这个 new 类 动作放在一个工厂的方法中，并返回。有的书上说，
                           变量不要直接持有具体类的引用。
                        ② 不要让类继承具体类，而是继承抽象类或者是实现 interface 接口。
       
                        ③ 不要覆盖基类中已经实现的方法。
                        
     原型模式: 
             基本介绍: 
                 1) 原型模式(Prototype模式)是指:用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
                 2) 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制单的对象，无需知道如何创建的细节
                 3) 工作原理是: 通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝
                                它们自己来实施创建，即对象.clone();
                 4) 形象的理解: 孙悟空拔猴毛，变出其他的孙悟空。
                 
             原型模式的注意事项和细节
                     1) 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
                     2) 不用重新初始化对象，而是动态地获取对象运行时的状态
                     3) 如果原始对象发生变化时(增加或者减少属性)，其它克隆对象也会发生相应的变化，无需修改代码
                     4) 在实现深克隆的时候可能需要比较复杂的代码
                     5) 缺点:需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要
                             修改其源代码，违背了ocp原则。

              
     浅拷贝的介绍
                    1) 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
                    2) 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行
                       引用传递，也就是只是将该成员变量的引用值(内存地址)复制一份给新的对象。因为实际上两个对象的该成员
                       变量都指向同一个实例。在这种情况下，在一个对象中修改成员变量会影响到另一个对象的该成员变量值。
                    3) 前面我们克隆羊就是浅拷贝
                    4) 浅拷贝是使用默认的.clone() 方法来实现
                            sheep = (Sheep) super.clone();
                            
     深拷贝基本介绍
                    1) 复制对象的所有基本数据类型的变量值
                    2) 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到
                       该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝
                    3) 深拷贝实现方式1: 重写 clone 方法来实现深拷贝
                    4) 深拷贝实现方式2: 通过对象序列化实现深拷贝(推荐)
                    

                    
                    
     建造者模式
                 基本介绍: 
                   1) 建造者模式(Builder Pattern) 又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来(抽象类别)，
                                 使这个抽象对象过程的不同实现方法可以构造出不同表现(属性)的对象。
                   2) 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道
                                 内部的具体构建细节。
                                 
                 建造者模式的四个角色:
                  1) Product(产品角色) : 一个具体的产品对象
                  2) Builder(抽象建造者) : 创建一个Product对象的各个部件指定的 接口/抽象类。
         
                  3) ConcreteBuilder(具体建造者) : 实现接口，构建和装配各个部件。
                  4) Director(指挥者) : 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用: 
                                        一是: 隔离了客户与对象的生产过程，二是: 负责控制产品对象的生产过程。
                                        
     建造者模式的注意事项和细节
              1) 客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使的相同的创建过程可以创建不同的产品对象。
              2) 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同
                 的具体建造者可得到不同的产品对象。
              3) 可以更加精细的控制产品的创建过程。将复杂的创建步骤分解在不同的方法中，使的创建过程更加清晰，也更方便使用程序来控制创建过程。
              4) 增加新的具体建造者无须修改原有类库的代码，指挥者针对抽象建造者类编程，系统扩展方便，符合“开闭原则”
              5) 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似 ，如果产品之间的差异性很大，则不合适使用建造者模式，
                 因此其使用范围受到一定的限制。
              6) 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，
                 要考虑是否选择建造者模式。
              7) 抽象工厂模式 VS 建造者模式
                 抽象工厂模式实现对产品家族的创建 ，一个产品家族是这样一系列产品:具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，
                 只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它们主要目的是通过组装零配件而产生一个新产品。
                 
     适配器模式:
            基本介绍
                1) 适配器模式(Adapter Pattern) 将某个类的接口转换成客户期望的另一个接口显示，主要的目的是兼容性，让原本因接口不匹配不能
                   一起工作的两个类可以协同工作。其别名为包装器(Wrapper)
                2) 适配器模式属于结构性模式
                3) 主要分为三类:类适配器、对象适配器、接口适配器模式
                
            工作原理:
                1) 适配器模式:将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容
                2) 从用户的角度看不到被适配者，是解耦的
                3) 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法
                4) 用户收到反馈结果，感觉只是和目标接口交互
                
                
          类适配器模式:
          类适配器模式注意事项和细节
                        1) Java 是单继承，所以类适配器需要继承 src 类这一点算是一个去缺点，因为这要求 dst 必须是接口，有一定局限性。
                        2) src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本
                        3) 由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得 Adapter 灵活性增强了。
               
                        
                       
          对象适配器模式:
          类适配器模式注意事项和细节
                       1) 对象适配器和类适配器算是同一种思想，只是实现方式不同，根据合成复用原则，使用组合替代继承，所以解决了类适配器必须继承 src 的局限性问题，
                                        也不再要求 dst 必须是接口。
                       2) 使用成本更低，更灵活
          接口适配器模式:
                接口适配器模式介绍
                       1) 一些书籍称为:适配器模式(Default Adapter Pattern) 或缺省适配器模式
                       2) 核心思想:当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个
                       3) 适用于一个接口不想使用其所有的方法情况。
                         
           适配器模式的注意事项和细节:
                       1) 三种命名方式，是根据 src 是以怎样的形势给Adapter(在Adapter里的形式)来命名的
                       2) 类适配器:以类给到，在Adapter里，就是将 src 当做类，继承
                          对象适配器:以对象给到，在Adapter里，将 src 作为一个对象，持有
                          接口适配器:以接口给到，在Adapter里，将 src 作为一个接口，实现
                       3) Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。
                       4) 实际开发中，实现起来不拘泥于这三种经典形式
                       
     桥接模式
          基本介绍:
              1) 桥接模式(Bridge Pattern)是指:将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。
              2) 是一种结构型设计模式。
              3) Bridge 模式基于类的最小设计原则，通过封装、聚合、及继承等行为让不同的类承担不同的职责。它的主要
                 特点是把抽象(Abstraction) 与行为实现(Implementation) 分离开来，从而可以保持各部分的独立性以及对
                 他们的功能扩展。
                 
          桥接模式的注意事项和细节
                      1) 实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，
                         这有助于系统进行分层设计，从而产生更好的结构化系统。
                      2) 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其他的部分是由具体业务来完成。
                      3) 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。
                      4) 桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。
          
                    5) 桥接模式要求正确识别出系统中两个独立变化的维度(抽象、和实现)，因此其使用范围有一定的局限性，即需要有这样
                       的应用场景。
          
                      对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为使用。
                      
     
     装饰者模式定义
               1) 装饰者模式: 动态的将功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)  
               2) 这里提到的动态的将新功能附加到对象和ocp原则，在后面的应用实例上回以代码的形势体现，注意体会
     
     装饰者模式原理
               1) 装饰者模式就像打包一个快递
                        主体:比如陶瓷、衣服   (Compnent)//被装饰者
                        包装:比如报纸填充、塑料泡沫、纸板、木板   (Decorator)//装饰者
               2) Component 主体:比如类似前面的Drink
               3) ConcreteCompnent 和 Decoreator
                     ConcreteCompnent : 具体的主体，比如前面的各个单品咖啡
               4) Decoreator 装饰者，比如各调料 
                    在如图Component与ConcreteCompnent 之间，如果  ConcreteCompnent 类很多，还可以设计一个缓冲层，将
                    共有的部分提取出来，抽象一个类。
                    
     组合模式基本介绍
              基本介绍:
                  1) 组合模式(Composite Pattern),又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状
                     以表示“整体-部分”的层次关系
                  2) 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。
                  3) 组合模式属于结构型模式。
                  4) 组合模式使的用户对单个对象和组合对象的访问具有一致性，即:
                     组合能让客户以一致的方式处理个别对象以及组合对象。
                     
                     
              组合模式的注意事项和细节
                  1) 简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。
                  2) 具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做任何改动。
                  3) 方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出
                     复杂的树形结构。
                  4) 需要遍历组织机构，或者处理的对象具有树形结构，非常合适使用组合模式
                  5) 要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不合适使用组合模式。
              
     外观模式
               基本介绍:
                   1) 外观模式(Facade),也叫“过程模式”:外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了
                      一个高层接口，这个接口使得这一子系统更加容易使用。
                   2) 外观模式通过定义一个一致接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需
                      关心这个子系统的内部细节。
                      
               外观模式的注意事项和细节
                   1) 外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性    
                   2) 外观模式对客户端与子系统的耦合关系-解耦，让子系统内部的模块更易维护和扩展
                   3) 通过合理的使用外观模式，可以帮助我们更好的划分访问的层次   
                   4) 当系统需要进行分层设计时，可以考虑用Facade模式
                   5) 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，
                      来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性。
                   6) 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。都是要以让系统有层次，利于维护为目的。


    享元模式
             基本介绍:
                 1) 享元模式(Flyweight Pattern) 也叫蝇量模式:运用共享技术有效地支持大量细粒度的对象。  
                 2) 常用于系统底层开发， 解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，
                    在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个。 
                 3) 享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池。不需
                    总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率。
                 4) 享元模式经典的应用场景就是池技术了，String常量池、数据库连接池、缓冲池等等都是
                    享元模式的应用，享元模式是池技术的重要实现方式。
                    
             内部状态和外部状态:
                      比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一些，
                      所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色
                      是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态。
                      1) 享元模式提出了两个要求:细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息
                         分为两个部分:内部状态和外部状态
                      2) 内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变。
                      3) 外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。
                      4) 举个例子:围棋理论上有361个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存
                                   空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么
                                   棋子对象就可以减少到只有两个实例(只创建两个对象黑棋和白棋)，这样就很好解决了对象的开销问题。
                                   
             享元模式的注意事项和细节:
                      1) 在享元模式这样理解，“享”就表示共享，“元”表示对象
                      2) 系统中有大量对象，这样对象消耗大量内存，并且对象的状态大部分可以外部化时，
                         我们就可以考虑选用享元模式。
                      3) 用唯一标识码判断，如果内存中有，则返回这个唯一标识码所标识的对象，用HashMap/ConcurrentHashMap。
                      4) 享元模式大大减减少了对象的创建，降低了程序内存的占用，提高效率。
                      5) 享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该
                         随着内部状态而改变，这是我们使用享元模式需要注意的地方。
                      6) 使用享元模式时，注意划分内部状态和外部状态，并且需要一个工厂类加一控制。
                      7) 享元模式经典的应用场景是需要缓冲的场景，比如Sting常量池，数据库连接池。
                      
                      
    代理模式(Proxy):
                代理模式基本介绍:
                               1) 代理模式:为一个对象提供一个替身，以控制这个对象的访问。即通过代理对象访问目标对象，
                                            这样的好处是:可以在目标对象实现的基础上，增强额外的功能操作，
                                            即扩展目标对象的功能。 
                               2) 被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象。
                               3) 代理模式有不同的形式，主要有三种:静态代理、动态代理(JKD代理、接口代理)和Cglib代理(可以
                                  在内存动态的创建对象，而不需要实现接口，他是属于动态代理范畴)。
                                  
                静态代理:
                    静态代理模式的基本介绍:
                                    静态代理在使用时，需要定义接口或者父类，被代理对象(即目标对象)与代理对象一起实现相同的接口
                                    或者是继承相同父类。
                                    
                    静态代理优缺点:
                                        1) 优点:在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展
                                        2) 缺点:因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类
                                        3) 一旦接口增加方法，目标对象与代理对象都要维护    
                                        
                JDK动态代理:
                    动态代理模式的基本介绍    
                                1) 代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理
                                2) 代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象
                                3) 动态代理也叫作:JKD代理、接口代理
                
                    JDK中生成代理对象的API
                                1) 代理类所在包:java.lang.reflect.Proxy
                                2) JDK实现代理只需要使用 newProxyInstance 方法，但是该方法需要接收三个参数，
                                   完整的写法是:
                                    public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)
                                    
                    Cglib动态代理:
                              Cglib代理模式的基本介绍
                                    1) 静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，
                                       并没有实现任何的接口，这个时候可使用目标对象子类来实现代理-这就是Cglib代理。
                                    2) Cglib代理也叫作子类代理，它是内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也
                                       将Cglib代理归属到动态代理
                                    3) Cglib是一个强大的高性能的代码生成包，它可以在运行期间扩展java类与实现java接口，它广泛的
                                       被许多AOP框架使用，实现方法拦截
                                    4) 在AOP编程中如何选择代理模式:
                                            1.目标对象需要实现接口，用JDK代理
                                            2.目标对象不需要实现接口，用Cglib代理
                                    5) Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类
    模板方法模式                           
            模板方法模式基本介绍:
                     1) 模板方法模式(Template Method Pattern),又叫模板模式(Template Pattern),在一个抽象类公开定义了
                        执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。
                     2) 简单说，模板方法模式定义一个操作中算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变
                        一个算法的结构，就可以重新定义该算法的某写特定步骤。
                     3) 这种类型的设计模式属于行为型模式。
                     
            模板方法模式的注意事项和细节:
                     1) 基本思想:算法只存在于一个地方，也就是父类中，容易修改。需要修改算法时，只要修改父类的模板方法
                                  或者已经实现的某些步骤，子类就会继承这些修改。
                     2) 实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用。
                     3) 既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分
                        步骤的实现。
                     4) 该模式的不足之处:每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大。
                     5) 一般模板方法都加上 final 关键字，防止子类重写模板方法。
                     6) 模板方法模式使用场景:当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤基本相同，但
                        其个别步骤在实现时可能不同，通常考虑用模方法模式来处理。
            
            
    命令模式
             基本介绍:
                 1) 命令模式(Command Pattern):在软件设计中，我们常常要向某些对象发送请求，但是并不知道请求的接收者是谁，也不
                    知道被请求的操作是什么。
                    我们只需在程序运行时指定具体的请求接受者即可，此时，可以使用命令模式来进行设计。
                 2) 命令模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。
                 3) 在命令模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时命令模式也支持可
                    撤销的操作。
                 4) 通俗易懂的理解:将军发布命令，士兵去执行命令。其中有几个角色:将军(命令发布者)、士兵(命令的具体执行者)、
                    命令(连接将军和士兵)。     
              
             命令模式的注意事项和细节:
                      1) 将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的execute()方法
                         就可以让接收者工作，而不知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，
                         也就是说:“请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。
                      2) 容易设计一个命令队列。只要把命令对象方到队列，就可以多线程的执行命令。
                      3) 容易实现对请求的撤销和重做。
                      4) 命令模式不足:可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在使用的时候要注意。
                      5) 空命令模式也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没有用空命令，我们
                         每按下一个按键都要判断空，这给我们编码带来一定的麻烦。
                      6) 命令模式经典的应用场景:界面的一个按键都是一条命令，模拟CMD(DOS命令)订单的撤销/恢复、触发-反馈机制。  


    访问者模式:
            基本介绍:   
                 1) 访问者模式(Visitor Pattern),封装了一些作用于某种数据结构的各元素的操作，它可以在不改变
                    数据结构前提定义作用于这些元素的新的操作。
                 2) 主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题。
                 3) 访问者模式的基本原理是：在被访问的类里面加一个对外提供接待访问者的接口。
                 4) 访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，
                    同时需要避免让这些操作“污染”这些对象的类，可以选用访问者模式解决。
                    
             访问者模式的注意事项和细节
                      优点 : 
                           1) 访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高
                           2) 访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统
             
                      缺点 : 
                           1) 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，
                              这样造成了具体元素变更比较困难。
                           2) 违背了依赖倒转原则。访问者依赖的具体元素，而不是抽象元素。
                           3) 因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的。
                           
                           
    迭代器模式:
            基本介绍:
                 1) 迭代器模式(Iterator Pattern) 是常用的设计模式，属于行为型模式。
                 2) 如果我们的集合元素是用的方式实现的，有数组，还有java的集合类，或者
                    还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，
                    而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。
                 3) 迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，
                    不需要知道集合对象的底层表示，即：不暴露内部的结构。
                    
            迭代器模式的注意事项和细节
                 优点:
                    1) 提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以
                        遍历对象了。
                    2) 隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚
                       合的具体组成。
                    3) 提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任
                       原则）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集
                       合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变
                       的话，只影响到了迭代器。
                    4) 当要展示一组相似对象，或者遍历一组相同对象时使用, 适合使用迭代器模式
                 缺点:
                    每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类
                    
    观察者模式原理
             1) 观察者模式类似订牛奶业务
             2) 奶站/气象局：Subject
             3) 用户/第三方网站：Observer
             Subject: 登记注册、移除和通知
               1) registerObserver  注册
               2) removeObserver    移除
               3) notifyObserver    通知所有的注册用户，根据不同需求，可以是更新数据，让用户来取，
                                    也可能是实时推送，看具体需求定
             Observer: 接收输入
    
             观察者模式: 对象之间多对一依赖的一种设计方案，被依赖的对象为Subject，依赖的对象为
                         Observer，Subject通知Observer变化，比如这里的奶站是Subject，是1的一方，
                         用户是Observer，是多的一方。
                         
              观察者模式的好处:
                             1) 观察者模式设计后，会以集合的方式来管理用户(Observer),包括注册，移除和通知。
                             2) 这样我们增加观察者(这里可以理解成一个新的公告板)，就不需要去修改核心类
                                WeatherData 不会修改代码，遵循了ocp原则。
                                
    中介者模式
             基本介绍:
                 1) 中介者模式(Mediator Pattern),用一个中介对象来封装一系列的对象交互。中介者
                    使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们
                    之间的交互。
                 2) 中介者模式属于行为型模式，使代码易于维护。
                 3) 比如MVC模式，C(Controller控制器) 是M(Model模型) 和V(View)视图的中介者，在
                    前后端交互时起到了中间人的作用。
                    
             中介者模式的注意事项和细节:
                      1) 多个类相互耦合，会形成网状结构, 使用中介者模式将网状结构分离为星型结构，
                         进行解耦。
                      2) 减少类间依赖，降低了耦合，符合迪米特原则。
                      3) 中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响。
                      4) 如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意。
                      
    备忘录模式
             基本介绍:
                 1) 备忘录模式(Memento Pattern) 在不破坏封装性的前提下，捕获一个对象内部状态，
                    并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的的状态。
                 2) 可以这里理解备忘录模式: 现实生活中的备忘录是用来记录某些要求做的事情，或者是
                    记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的
                    意义，备忘录模式主要用来记录一个对象的某种状态，或者某些数据，当要做撤回时，
                    可以从备忘录对象里获取原来的数据进行恢复操作。
                 3) 备忘录模式属于行为型模式
                 
             备忘录模式的注意事项和细节:
                      1) 给用户提供了一种可以恢复状态的机制，可以使用户能够方便的回到某个历史的状态。   
                      2) 实现了信息的封装，使得用户不需关心状态的保存细节。
                      3) 如果类的成员变量过多，势必会占用比较大的资源，而且每保存一次都回消耗一定的
                         内存，这个需要注意。
                      4) 适用的应用场景:
                             1.后悔药
                             2.打游戏的存档
                             3.Windows里的 ctrl+z 
                             4.IE中后退
                             5.数据库的事务管理    
                      5) 为了节约内存，备忘录模式可以和原形模式配合使用。